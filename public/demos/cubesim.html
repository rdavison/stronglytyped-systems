<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>cubesim — Rubik's Cube Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Inter:wght@400;500&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a10; color: #D3C6AA; font-family: 'Inter', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; gap: 16px; overflow: hidden; }

  canvas { cursor: grab; }
  canvas:active { cursor: grabbing; }

  .controls { display: flex; gap: 8px; align-items: center; }
  .btn { font-family: 'JetBrains Mono', monospace; font-size: 10px; padding: 6px 14px; background: transparent; border: 1px solid rgba(167,192,128,0.15); color: #7A8478; border-radius: 4px; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.15s; }
  .btn:hover { color: #D3C6AA; border-color: rgba(167,192,128,0.35); }
  .btn.accent { border-color: rgba(155,77,106,0.4); color: #9B4D6A; }
  .btn.accent:hover { border-color: rgba(155,77,106,0.7); color: #D3C6AA; background: rgba(155,77,106,0.1); }

  .stats { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: #7A8478; display: flex; gap: 16px; }
  .stats span { color: #A7C080; }

  .face-btns { display: flex; gap: 4px; }
  .face-btn { font-family: 'JetBrains Mono', monospace; font-size: 9px; padding: 4px 8px; background: transparent; border: 1px solid rgba(167,192,128,0.1); color: #7A8478; border-radius: 3px; cursor: pointer; transition: all 0.15s; }
  .face-btn:hover { border-color: rgba(167,192,128,0.3); color: #D3C6AA; }
</style>
</head>
<body>
<canvas id="cube" width="400" height="340"></canvas>
<div class="face-btns">
  <button class="face-btn" onclick="doMove('U')">U</button>
  <button class="face-btn" onclick="doMove('D')">D</button>
  <button class="face-btn" onclick="doMove('L')">L</button>
  <button class="face-btn" onclick="doMove('R')">R</button>
  <button class="face-btn" onclick="doMove('F')">F</button>
  <button class="face-btn" onclick="doMove('B')">B</button>
  <button class="face-btn" onclick="doMove('U',true)">U'</button>
  <button class="face-btn" onclick="doMove('R',true)">R'</button>
  <button class="face-btn" onclick="doMove('F',true)">F'</button>
</div>
<div class="controls">
  <button class="btn accent" onclick="scramble()">Scramble</button>
  <button class="btn" onclick="resetCube()">Reset</button>
</div>
<div class="stats">Moves: <span id="moves">0</span> &nbsp; State: <span id="state">Solved</span></div>

<script>
const canvas = document.getElementById('cube');
const ctx = canvas.getContext('2d');

// Everforest-inspired Rubik's face colors
const COLORS = ['#E8E8E8', '#DBBC7F', '#A7C080', '#7FBBB3', '#D699B6', '#E67E80'];
const FACE_NAMES = ['U','D','F','B','L','R'];

let faces = {};
let moveCount = 0;
let animating = false;
let moveQueue = [];

// Camera rotation (draggable)
let rotX = -25 * Math.PI / 180;
let rotY = 35 * Math.PI / 180;
let dragging = false;
let dragStartX = 0, dragStartY = 0;
let dragStartRotX = 0, dragStartRotY = 0;

function initFaces() {
  faces = {};
  for (let i = 0; i < 6; i++) {
    faces[FACE_NAMES[i]] = Array(9).fill(i);
  }
}

function rotateFaceCW(name) {
  const f = faces[name];
  faces[name] = [f[6],f[3],f[0],f[7],f[4],f[1],f[8],f[5],f[2]];
}

function applyMove(m, ccw) {
  if (ccw) { applyMove(m, false); applyMove(m, false); applyMove(m, false); return; }
  switch(m) {
    case 'U':
      rotateFaceCW('U');
      var t = [faces.F[0],faces.F[1],faces.F[2]];
      faces.F[0]=faces.R[0]; faces.F[1]=faces.R[1]; faces.F[2]=faces.R[2];
      faces.R[0]=faces.B[0]; faces.R[1]=faces.B[1]; faces.R[2]=faces.B[2];
      faces.B[0]=faces.L[0]; faces.B[1]=faces.L[1]; faces.B[2]=faces.L[2];
      faces.L[0]=t[0]; faces.L[1]=t[1]; faces.L[2]=t[2];
      break;
    case 'D':
      rotateFaceCW('D');
      var t = [faces.F[6],faces.F[7],faces.F[8]];
      faces.F[6]=faces.L[6]; faces.F[7]=faces.L[7]; faces.F[8]=faces.L[8];
      faces.L[6]=faces.B[6]; faces.L[7]=faces.B[7]; faces.L[8]=faces.B[8];
      faces.B[6]=faces.R[6]; faces.B[7]=faces.R[7]; faces.B[8]=faces.R[8];
      faces.R[6]=t[0]; faces.R[7]=t[1]; faces.R[8]=t[2];
      break;
    case 'F':
      rotateFaceCW('F');
      var t = [faces.U[6],faces.U[7],faces.U[8]];
      faces.U[6]=faces.L[8]; faces.U[7]=faces.L[5]; faces.U[8]=faces.L[2];
      faces.L[2]=faces.D[0]; faces.L[5]=faces.D[1]; faces.L[8]=faces.D[2];
      faces.D[0]=faces.R[6]; faces.D[1]=faces.R[3]; faces.D[2]=faces.R[0];
      faces.R[0]=t[0]; faces.R[3]=t[1]; faces.R[6]=t[2];
      break;
    case 'B':
      rotateFaceCW('B');
      var t = [faces.U[0],faces.U[1],faces.U[2]];
      faces.U[0]=faces.R[2]; faces.U[1]=faces.R[5]; faces.U[2]=faces.R[8];
      faces.R[2]=faces.D[8]; faces.R[5]=faces.D[7]; faces.R[8]=faces.D[6];
      faces.D[6]=faces.L[0]; faces.D[7]=faces.L[3]; faces.D[8]=faces.L[6];
      faces.L[0]=t[2]; faces.L[3]=t[1]; faces.L[6]=t[0];
      break;
    case 'L':
      rotateFaceCW('L');
      var t = [faces.U[0],faces.U[3],faces.U[6]];
      faces.U[0]=faces.B[8]; faces.U[3]=faces.B[5]; faces.U[6]=faces.B[2];
      faces.B[2]=faces.D[6]; faces.B[5]=faces.D[3]; faces.B[8]=faces.D[0];
      faces.D[0]=faces.F[0]; faces.D[3]=faces.F[3]; faces.D[6]=faces.F[6];
      faces.F[0]=t[0]; faces.F[3]=t[1]; faces.F[6]=t[2];
      break;
    case 'R':
      rotateFaceCW('R');
      var t = [faces.U[2],faces.U[5],faces.U[8]];
      faces.U[2]=faces.F[2]; faces.U[5]=faces.F[5]; faces.U[8]=faces.F[8];
      faces.F[2]=faces.D[2]; faces.F[5]=faces.D[5]; faces.F[8]=faces.D[8];
      faces.D[2]=faces.B[6]; faces.D[5]=faces.B[3]; faces.D[8]=faces.B[0];
      faces.B[0]=t[2]; faces.B[3]=t[1]; faces.B[6]=t[0];
      break;
  }
}

// ---- True perspective 3D projection ----
const CUBE_SIZE = 1.5; // half-size of the cube in world units
const CELL = CUBE_SIZE * 2 / 3; // size of one sticker cell
const FOV = 600; // field of view (perspective strength)
const CX = 200, CY = 160; // screen center

function multiply(a, b) {
  // 3x3 matrix multiply
  const r = [[0,0,0],[0,0,0],[0,0,0]];
  for (let i = 0; i < 3; i++)
    for (let j = 0; j < 3; j++)
      for (let k = 0; k < 3; k++)
        r[i][j] += a[i][k] * b[k][j];
  return r;
}

function rotMatX(a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [[1,0,0],[0,c,-s],[0,s,c]];
}

function rotMatY(a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [[c,0,s],[0,1,0],[-s,0,c]];
}

function transform(p) {
  // Apply rotation then perspective projection
  const mat = multiply(rotMatX(rotX), rotMatY(rotY));
  const x = mat[0][0]*p[0] + mat[0][1]*p[1] + mat[0][2]*p[2];
  const y = mat[1][0]*p[0] + mat[1][1]*p[1] + mat[1][2]*p[2];
  const z = mat[2][0]*p[0] + mat[2][1]*p[1] + mat[2][2]*p[2];
  const depth = z + 6; // push back so it's always in front of camera
  const scale = FOV / depth;
  return { sx: CX + x * scale, sy: CY - y * scale, z: z };
}

// Generate the 4 corners of a sticker on a given face
function stickerQuad(faceName, row, col) {
  const s = CUBE_SIZE;
  const c = CELL;
  const gap = 0.04; // gap between stickers
  const r0 = -s + col * c + gap;
  const r1 = -s + (col + 1) * c - gap;
  const c0 = s - row * c - gap;
  const c1 = s - (row + 1) * c + gap;

  let pts;
  switch (faceName) {
    case 'U': // y = +s
      pts = [[r0,s,-c0],[r1,s,-c0],[r1,s,-c1],[r0,s,-c1]]; break;
    case 'D': // y = -s
      pts = [[r0,-s,c0],[r1,-s,c0],[r1,-s,c1],[r0,-s,c1]]; break;
    case 'F': // z = +s
      pts = [[r0,c0,s],[r1,c0,s],[r1,c1,s],[r0,c1,s]]; break;
    case 'B': // z = -s
      pts = [[r1,c0,-s],[r0,c0,-s],[r0,c1,-s],[r1,c1,-s]]; break;
    case 'L': // x = -s
      pts = [[-s,c0,-r0],[-s,c0,-r1],[-s,c1,-r1],[-s,c1,-r0]]; break;
    case 'R': // x = +s
      pts = [[s,c0,r0],[s,c0,r1],[s,c1,r1],[s,c1,r0]]; break;
  }
  return pts;
}

function faceNormal(faceName) {
  switch (faceName) {
    case 'U': return [0,1,0];
    case 'D': return [0,-1,0];
    case 'F': return [0,0,1];
    case 'B': return [0,0,-1];
    case 'L': return [-1,0,0];
    case 'R': return [1,0,0];
  }
}

function darken(hex, factor) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgb(${Math.round(r * factor)}, ${Math.round(g * factor)}, ${Math.round(b * factor)})`;
}

function drawQuad(screenPts, color) {
  ctx.beginPath();
  ctx.moveTo(screenPts[0].sx, screenPts[0].sy);
  for (let i = 1; i < screenPts.length; i++) ctx.lineTo(screenPts[i].sx, screenPts[i].sy);
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
  ctx.strokeStyle = 'rgba(10, 10, 16, 0.6)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Compute rotation matrix for face visibility
  const mat = multiply(rotMatX(rotX), rotMatY(rotY));

  // Collect all visible stickers with depth info
  const stickers = [];

  for (const faceName of FACE_NAMES) {
    // Check if face is visible (dot product of normal with view direction > 0)
    const n = faceNormal(faceName);
    const tn = [
      mat[0][0]*n[0] + mat[0][1]*n[1] + mat[0][2]*n[2],
      mat[1][0]*n[0] + mat[1][1]*n[1] + mat[1][2]*n[2],
      mat[2][0]*n[0] + mat[2][1]*n[1] + mat[2][2]*n[2]
    ];
    // Face is visible if it faces the camera (z component < 0 in our setup)
    if (tn[2] >= 0.01) continue;

    // Lighting: use the normal to compute brightness
    const lightDir = [0.3, 0.7, -0.8]; // light from upper-right-front
    const lLen = Math.sqrt(lightDir[0]**2 + lightDir[1]**2 + lightDir[2]**2);
    const dot = -(tn[0]*lightDir[0] + tn[1]*lightDir[1] + tn[2]*lightDir[2]) / lLen;
    const brightness = 0.55 + 0.45 * Math.max(0, dot);

    const faceData = faces[faceName];
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 3; c++) {
        const pts3d = stickerQuad(faceName, r, c);
        const screenPts = pts3d.map(p => transform(p));
        const avgZ = screenPts.reduce((sum, p) => sum + p.z, 0) / 4;
        stickers.push({
          screenPts,
          color: darken(COLORS[faceData[r * 3 + c]], brightness),
          z: avgZ
        });
      }
    }
  }

  // Draw cube body (dark silhouette behind stickers)
  const corners3d = [];
  for (const x of [-CUBE_SIZE, CUBE_SIZE])
    for (const y of [-CUBE_SIZE, CUBE_SIZE])
      for (const z of [-CUBE_SIZE, CUBE_SIZE])
        corners3d.push(transform([x, y, z]));

  // Sort stickers back-to-front
  stickers.sort((a, b) => b.z - a.z);
  for (const s of stickers) {
    drawQuad(s.screenPts, s.color);
  }
}

function isSolved() {
  for (const name of FACE_NAMES) {
    const f = faces[name];
    if (!f.every(c => c === f[0])) return false;
  }
  return true;
}

function updateStats() {
  document.getElementById('moves').textContent = moveCount;
  document.getElementById('state').textContent = isSolved() ? 'Solved' : 'Scrambled';
  document.getElementById('state').style.color = isSolved() ? '#A7C080' : '#DBBC7F';
}

function doMove(m, ccw) {
  if (animating) { moveQueue.push([m, ccw]); return; }
  applyMove(m, !!ccw);
  moveCount++;
  draw();
  updateStats();
}

function scramble() {
  const moves = 'UDLRFB';
  moveCount = 0;
  let i = 0;
  animating = true;
  function next() {
    if (i >= 20) { animating = false; updateStats(); processQueue(); return; }
    applyMove(moves[Math.floor(Math.random() * 6)], Math.random() > 0.5);
    moveCount++;
    draw();
    i++;
    setTimeout(next, 50);
  }
  next();
}

function processQueue() {
  if (moveQueue.length > 0) {
    const [m, ccw] = moveQueue.shift();
    doMove(m, ccw);
  }
}

function resetCube() {
  initFaces();
  moveCount = 0;
  moveQueue = [];
  animating = false;
  draw();
  updateStats();
}

// Mouse drag to rotate
canvas.addEventListener('mousedown', (e) => {
  dragging = true;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  dragStartRotX = rotX;
  dragStartRotY = rotY;
});

window.addEventListener('mousemove', (e) => {
  if (!dragging) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  rotY = dragStartRotY + dx * 0.008;
  rotX = dragStartRotX - dy * 0.008;
  // Clamp vertical rotation
  rotX = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, rotX));
  draw();
});

window.addEventListener('mouseup', () => { dragging = false; });

// Click on face buttons (not drag) — detect by checking if mouse didn't move
canvas.addEventListener('click', (e) => {
  if (animating) return;
  const dx = Math.abs(e.clientX - dragStartX);
  const dy = Math.abs(e.clientY - dragStartY);
  if (dx > 3 || dy > 3) return; // was a drag, not a click

  // Determine which visible face was clicked using raycast approximation
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top) * (canvas.height / rect.height);

  // Simple heuristic: which face center is closest to click?
  const mat = multiply(rotMatX(rotX), rotMatY(rotY));
  let bestFace = null, bestDist = Infinity;
  for (const faceName of FACE_NAMES) {
    const n = faceNormal(faceName);
    const tn2 = mat[2][0]*n[0] + mat[2][1]*n[1] + mat[2][2]*n[2];
    if (tn2 >= 0) continue; // not visible

    const center = faceNormal(faceName).map(v => v * CUBE_SIZE);
    const sc = transform(center);
    const dist = Math.sqrt((sc.sx - mx)**2 + (sc.sy - my)**2);
    if (dist < bestDist) { bestDist = dist; bestFace = faceName; }
  }
  if (bestFace && bestDist < 120) doMove(bestFace);
});

// Gentle idle rotation
let idleAnim = null;
function startIdle() {
  if (dragging) return;
  idleAnim = requestAnimationFrame(idleTick);
}
function idleTick() {
  if (dragging) return;
  rotY += 0.003;
  draw();
  idleAnim = requestAnimationFrame(idleTick);
}

initFaces();
draw();
updateStats();
startIdle();
</script>
</body>
</html>
