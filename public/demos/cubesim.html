<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>cubesim — Rubik's Cube Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Inter:wght@400;500&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a10; color: #D3C6AA; font-family: 'Inter', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; gap: 16px; overflow: hidden; }

  canvas { cursor: grab; }
  canvas:active { cursor: grabbing; }

  .controls { display: flex; gap: 8px; align-items: center; }
  .btn { font-family: 'JetBrains Mono', monospace; font-size: 10px; padding: 6px 14px; background: transparent; border: 1px solid rgba(167,192,128,0.15); color: #7A8478; border-radius: 4px; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.15s; }
  .btn:hover { color: #D3C6AA; border-color: rgba(167,192,128,0.35); }
  .btn.accent { border-color: rgba(155,77,106,0.4); color: #9B4D6A; }
  .btn.accent:hover { border-color: rgba(155,77,106,0.7); color: #D3C6AA; background: rgba(155,77,106,0.1); }

  .stats { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: #7A8478; display: flex; gap: 16px; }
  .stats span { color: #A7C080; }

  .face-btns { display: flex; gap: 4px; }
  .face-btn { font-family: 'JetBrains Mono', monospace; font-size: 9px; padding: 4px 8px; background: transparent; border: 1px solid rgba(167,192,128,0.1); color: #7A8478; border-radius: 3px; cursor: pointer; transition: all 0.15s; }
  .face-btn:hover { border-color: rgba(167,192,128,0.3); color: #D3C6AA; }
</style>
</head>
<body>
<canvas id="cube" width="400" height="340"></canvas>
<div class="face-btns">
  <button class="face-btn" onclick="doMove('U')">U</button>
  <button class="face-btn" onclick="doMove('D')">D</button>
  <button class="face-btn" onclick="doMove('L')">L</button>
  <button class="face-btn" onclick="doMove('R')">R</button>
  <button class="face-btn" onclick="doMove('F')">F</button>
  <button class="face-btn" onclick="doMove('B')">B</button>
  <button class="face-btn" onclick="doMove('U',true)">U'</button>
  <button class="face-btn" onclick="doMove('D',true)">D'</button>
  <button class="face-btn" onclick="doMove('L',true)">L'</button>
  <button class="face-btn" onclick="doMove('R',true)">R'</button>
  <button class="face-btn" onclick="doMove('F',true)">F'</button>
  <button class="face-btn" onclick="doMove('B',true)">B'</button>
</div>
<div class="controls">
  <button class="btn accent" onclick="scramble()">Scramble</button>
  <button class="btn" onclick="resetCube()">Reset</button>
</div>
<div class="stats">Moves: <span id="moves">0</span> &nbsp; State: <span id="state">Solved</span></div>

<script>
const canvas = document.getElementById('cube');
const ctx = canvas.getContext('2d');

// Everforest-inspired Rubik's face colors
const COLORS = ['#E8E8E8', '#DBBC7F', '#A7C080', '#7FBBB3', '#D699B6', '#E67E80'];
const FACE_NAMES = ['U','D','F','B','L','R'];

let faces = {};
let moveCount = 0;
let moveQueue = [];

// Camera rotation (draggable)
let rotX = -25 * Math.PI / 180;
let rotY = 35 * Math.PI / 180;
let dragging = false;
let dragStartX = 0, dragStartY = 0;
let dragStartRotX = 0, dragStartRotY = 0;

// Animation state
let anim = null; // { face, ccw, progress, startTime, duration }
const ANIM_DURATION = 250; // ms per face turn

function initFaces() {
  faces = {};
  for (let i = 0; i < 6; i++) {
    faces[FACE_NAMES[i]] = Array(9).fill(i);
  }
}

function rotateFaceCW(name) {
  const f = faces[name];
  faces[name] = [f[6],f[3],f[0],f[7],f[4],f[1],f[8],f[5],f[2]];
}

function applyMove(m, ccw) {
  if (ccw) { applyMove(m, false); applyMove(m, false); applyMove(m, false); return; }
  // All permutations derived from 3D cubie coordinate geometry.
  // Each face's sticker (row,col) maps to a world position; the CW rotation
  // transform determines which sticker index moves where, including reversals
  // at face boundaries where coordinate axes flip orientation.
  switch(m) {
    case 'U':
      // U CW (looking down): F→R(rev), R→B, B→L, L(rev)→F
      rotateFaceCW('U');
      var t = [faces.F[0], faces.F[1], faces.F[2]];
      faces.F[0]=faces.L[2]; faces.F[1]=faces.L[1]; faces.F[2]=faces.L[0];
      faces.L[0]=faces.B[0]; faces.L[1]=faces.B[1]; faces.L[2]=faces.B[2];
      faces.B[0]=faces.R[0]; faces.B[1]=faces.R[1]; faces.B[2]=faces.R[2];
      faces.R[0]=t[2]; faces.R[1]=t[1]; faces.R[2]=t[0];
      break;
    case 'D':
      // D CW (looking up from below): F→L(rev), L→B, B→R, R(rev)→F
      rotateFaceCW('D');
      var t = [faces.F[6], faces.F[7], faces.F[8]];
      faces.F[6]=faces.R[8]; faces.F[7]=faces.R[7]; faces.F[8]=faces.R[6];
      faces.R[6]=faces.B[6]; faces.R[7]=faces.B[7]; faces.R[8]=faces.B[8];
      faces.B[6]=faces.L[6]; faces.B[7]=faces.L[7]; faces.B[8]=faces.L[8];
      faces.L[6]=t[2]; faces.L[7]=t[1]; faces.L[8]=t[0];
      break;
    case 'F':
      // F CW (looking at front): U→R, R(rev)→D, D→L, L(rev)→U
      rotateFaceCW('F');
      var t = [faces.U[6], faces.U[7], faces.U[8]];
      faces.U[6]=faces.L[6]; faces.U[7]=faces.L[3]; faces.U[8]=faces.L[0];
      faces.L[0]=faces.D[0]; faces.L[3]=faces.D[1]; faces.L[6]=faces.D[2];
      faces.D[0]=faces.R[8]; faces.D[1]=faces.R[5]; faces.D[2]=faces.R[2];
      faces.R[2]=t[0]; faces.R[5]=t[1]; faces.R[8]=t[2];
      break;
    case 'B':
      // B CW (looking at back from behind): U→L(rev), L→D, D(rev)→R, R→U
      rotateFaceCW('B');
      var t = [faces.U[0], faces.U[1], faces.U[2]];
      faces.U[0]=faces.R[0]; faces.U[1]=faces.R[3]; faces.U[2]=faces.R[6];
      faces.R[0]=faces.D[8]; faces.R[3]=faces.D[7]; faces.R[6]=faces.D[6];
      faces.D[6]=faces.L[2]; faces.D[7]=faces.L[5]; faces.D[8]=faces.L[8];
      faces.L[2]=t[2]; faces.L[5]=t[1]; faces.L[8]=t[0];
      break;
    case 'L':
      // L CW (looking from left): U→B(rev), B(rev)→D, D→F, F→U
      rotateFaceCW('L');
      var t = [faces.U[0], faces.U[3], faces.U[6]];
      faces.U[0]=faces.F[0]; faces.U[3]=faces.F[3]; faces.U[6]=faces.F[6];
      faces.F[0]=faces.D[0]; faces.F[3]=faces.D[3]; faces.F[6]=faces.D[6];
      faces.D[0]=faces.B[6]; faces.D[3]=faces.B[3]; faces.D[6]=faces.B[0];
      faces.B[0]=t[2]; faces.B[3]=t[1]; faces.B[6]=t[0];
      break;
    case 'R':
      // R CW (looking from right): U→F, F→D, D→B(rev), B(rev)→U
      rotateFaceCW('R');
      var t = [faces.U[2], faces.U[5], faces.U[8]];
      faces.U[2]=faces.B[8]; faces.U[5]=faces.B[5]; faces.U[8]=faces.B[2];
      faces.B[2]=faces.D[8]; faces.B[5]=faces.D[5]; faces.B[8]=faces.D[2];
      faces.D[2]=faces.F[2]; faces.D[5]=faces.F[5]; faces.D[8]=faces.F[8];
      faces.F[2]=t[0]; faces.F[5]=t[1]; faces.F[8]=t[2];
      break;
  }
}

// ---- True perspective 3D projection ----
const CUBE_SIZE = 1.5;
const CELL = CUBE_SIZE * 2 / 3;
const FOV = 600;
const CX = 200, CY = 160;

function multiply(a, b) {
  const r = [[0,0,0],[0,0,0],[0,0,0]];
  for (let i = 0; i < 3; i++)
    for (let j = 0; j < 3; j++)
      for (let k = 0; k < 3; k++)
        r[i][j] += a[i][k] * b[k][j];
  return r;
}

function rotMatX(a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [[1,0,0],[0,c,-s],[0,s,c]];
}

function rotMatY(a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [[c,0,s],[0,1,0],[-s,0,c]];
}

function rotMatZ(a) {
  const c = Math.cos(a), s = Math.sin(a);
  return [[c,-s,0],[s,c,0],[0,0,1]];
}

function transformPt(p, mat) {
  const x = mat[0][0]*p[0] + mat[0][1]*p[1] + mat[0][2]*p[2];
  const y = mat[1][0]*p[0] + mat[1][1]*p[1] + mat[1][2]*p[2];
  const z = mat[2][0]*p[0] + mat[2][1]*p[1] + mat[2][2]*p[2];
  return [x, y, z];
}

function project(p) {
  const depth = p[2] + 6;
  const scale = FOV / depth;
  return { sx: CX + p[0] * scale, sy: CY - p[1] * scale, z: p[2] };
}

// Get the rotation axis and which stickers are affected by a face move
function getFaceAxis(faceName) {
  switch (faceName) {
    case 'U': return { axis: [0, 1, 0], layer: 1 };  // +Y
    case 'D': return { axis: [0, -1, 0], layer: 1 };  // -Y
    case 'F': return { axis: [0, 0, 1], layer: 1 };   // +Z
    case 'B': return { axis: [0, 0, -1], layer: 1 };  // -Z
    case 'L': return { axis: [-1, 0, 0], layer: 1 };  // -X
    case 'R': return { axis: [1, 0, 0], layer: 1 };   // +X
  }
}

// Determine which face stickers participate in a face move (face itself + adjacent strips)
function getAffectedStickers(moveFace) {
  // Returns set of { face, row, col } that should rotate during animation
  const affected = [];
  // The face itself: all 9 stickers
  for (let r = 0; r < 3; r++)
    for (let c = 0; c < 3; c++)
      affected.push({ face: moveFace, r, c });

  // Adjacent strips
  switch (moveFace) {
    case 'U':
      for (let c = 0; c < 3; c++) {
        affected.push({ face: 'F', r: 0, c });
        affected.push({ face: 'R', r: 0, c });
        affected.push({ face: 'B', r: 0, c });
        affected.push({ face: 'L', r: 0, c });
      }
      break;
    case 'D':
      for (let c = 0; c < 3; c++) {
        affected.push({ face: 'F', r: 2, c });
        affected.push({ face: 'R', r: 2, c });
        affected.push({ face: 'B', r: 2, c });
        affected.push({ face: 'L', r: 2, c });
      }
      break;
    case 'F':
      for (let i = 0; i < 3; i++) {
        affected.push({ face: 'U', r: 2, c: i });
        affected.push({ face: 'D', r: 0, c: i });
        affected.push({ face: 'L', r: i, c: 0 });
        affected.push({ face: 'R', r: i, c: 2 });
      }
      break;
    case 'B':
      for (let i = 0; i < 3; i++) {
        affected.push({ face: 'U', r: 0, c: i });
        affected.push({ face: 'D', r: 2, c: i });
        affected.push({ face: 'L', r: i, c: 2 });
        affected.push({ face: 'R', r: i, c: 0 });
      }
      break;
    case 'L':
      for (let i = 0; i < 3; i++) {
        affected.push({ face: 'U', r: i, c: 0 });
        affected.push({ face: 'D', r: i, c: 0 });
        affected.push({ face: 'F', r: i, c: 0 });
        affected.push({ face: 'B', r: i, c: 0 });
      }
      break;
    case 'R':
      for (let i = 0; i < 3; i++) {
        affected.push({ face: 'U', r: i, c: 2 });
        affected.push({ face: 'D', r: i, c: 2 });
        affected.push({ face: 'F', r: i, c: 2 });
        affected.push({ face: 'B', r: i, c: 2 });
      }
      break;
  }
  return affected;
}

// Build the rotation matrix for animating a face turn
function faceAnimMatrix(faceName, angle) {
  // Signs derived so that +angle = CW when viewing each face from outside.
  // U/R use positive axis rotation; D/L negate to reverse axis;
  // F/B swap signs relative to naive Z-rotation due to viewing direction.
  switch (faceName) {
    case 'U': return rotMatY(angle);
    case 'D': return rotMatY(-angle);
    case 'R': return rotMatX(angle);
    case 'L': return rotMatX(-angle);
    case 'F': return rotMatZ(-angle);
    case 'B': return rotMatZ(angle);
  }
}

// Check if a sticker belongs to the animated set
function isAffected(faceName, r, c, affectedSet) {
  for (const a of affectedSet) {
    if (a.face === faceName && a.r === r && a.c === c) return true;
  }
  return false;
}

function stickerQuad(faceName, row, col) {
  const s = CUBE_SIZE;
  const c = CELL;
  const gap = 0.04;
  const r0 = -s + col * c + gap;
  const r1 = -s + (col + 1) * c - gap;
  const c0 = s - row * c - gap;
  const c1 = s - (row + 1) * c + gap;

  let pts;
  switch (faceName) {
    case 'U': pts = [[r0,s,-c0],[r1,s,-c0],[r1,s,-c1],[r0,s,-c1]]; break;
    case 'D': pts = [[r0,-s,c0],[r1,-s,c0],[r1,-s,c1],[r0,-s,c1]]; break;
    case 'F': pts = [[r0,c0,s],[r1,c0,s],[r1,c1,s],[r0,c1,s]]; break;
    case 'B': pts = [[r1,c0,-s],[r0,c0,-s],[r0,c1,-s],[r1,c1,-s]]; break;
    case 'L': pts = [[-s,c0,-r0],[-s,c0,-r1],[-s,c1,-r1],[-s,c1,-r0]]; break;
    case 'R': pts = [[s,c0,r0],[s,c0,r1],[s,c1,r1],[s,c1,r0]]; break;
  }
  return pts;
}

function faceNormal(faceName) {
  switch (faceName) {
    case 'U': return [0,1,0];
    case 'D': return [0,-1,0];
    case 'F': return [0,0,1];
    case 'B': return [0,0,-1];
    case 'L': return [-1,0,0];
    case 'R': return [1,0,0];
  }
}

function darken(hex, factor) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgb(${Math.round(r * factor)}, ${Math.round(g * factor)}, ${Math.round(b * factor)})`;
}

function drawQuad(screenPts, color) {
  ctx.beginPath();
  ctx.moveTo(screenPts[0].sx, screenPts[0].sy);
  for (let i = 1; i < screenPts.length; i++) ctx.lineTo(screenPts[i].sx, screenPts[i].sy);
  ctx.closePath();
  ctx.fillStyle = color;
  ctx.fill();
  ctx.strokeStyle = 'rgba(10, 10, 16, 0.6)';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const cameraMat = multiply(rotMatX(rotX), rotMatY(rotY));

  // Build the face animation rotation matrix if animating
  let animMat = null;
  let affectedSet = null;
  if (anim) {
    animMat = faceAnimMatrix(anim.face, anim.currentAngle);
    affectedSet = getAffectedStickers(anim.face);
  }

  const lightDir = [0.3, 0.7, -0.8];
  const lLen = Math.sqrt(lightDir[0]**2 + lightDir[1]**2 + lightDir[2]**2);

  const stickers = [];

  for (const faceName of FACE_NAMES) {
    const faceData = faces[faceName];
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 3; c++) {
        let pts3d = stickerQuad(faceName, r, c);
        let normal = faceNormal(faceName);

        // If this sticker is part of the animated face, apply the face rotation
        if (anim && isAffected(faceName, r, c, affectedSet)) {
          pts3d = pts3d.map(p => transformPt(p, animMat));
          normal = transformPt(normal, animMat);
        }

        // Apply camera rotation
        const camPts = pts3d.map(p => transformPt(p, cameraMat));
        const camNormal = transformPt(normal, cameraMat);

        // Back-face culling
        if (camNormal[2] >= 0.01) continue;

        // Lighting
        const dot = -(camNormal[0]*lightDir[0] + camNormal[1]*lightDir[1] + camNormal[2]*lightDir[2]) / lLen;
        const brightness = 0.55 + 0.45 * Math.max(0, dot);

        const screenPts = camPts.map(p => project(p));
        const avgZ = screenPts.reduce((sum, p) => sum + p.z, 0) / 4;
        stickers.push({
          screenPts,
          color: darken(COLORS[faceData[r * 3 + c]], brightness),
          z: avgZ
        });
      }
    }
  }

  // Sort stickers back-to-front (painter's algorithm)
  stickers.sort((a, b) => b.z - a.z);
  for (const s of stickers) {
    drawQuad(s.screenPts, s.color);
  }
}

function isSolved() {
  for (const name of FACE_NAMES) {
    const f = faces[name];
    if (!f.every(c => c === f[0])) return false;
  }
  return true;
}

function updateStats() {
  document.getElementById('moves').textContent = moveCount;
  document.getElementById('state').textContent = isSolved() ? 'Solved' : 'Scrambled';
  document.getElementById('state').style.color = isSolved() ? '#A7C080' : '#DBBC7F';
}

// Easing function: smooth deceleration
function easeOutCubic(t) {
  return 1 - Math.pow(1 - t, 3);
}

function animateTurn() {
  if (!anim) return;
  const now = performance.now();
  const elapsed = now - anim.startTime;
  const t = Math.min(1, elapsed / anim.duration);
  const eased = easeOutCubic(t);

  const targetAngle = anim.ccw ? Math.PI / 2 : -Math.PI / 2;
  anim.currentAngle = targetAngle * eased;

  draw();

  if (t < 1) {
    requestAnimationFrame(animateTurn);
  } else {
    // Animation complete — apply the actual state change
    applyMove(anim.face, anim.ccw);
    anim = null;
    moveCount++;
    updateStats();
    draw();
    processQueue();
  }
}

function doMove(m, ccw) {
  if (anim) { moveQueue.push([m, !!ccw]); return; }
  // Start animated turn
  anim = {
    face: m,
    ccw: !!ccw,
    progress: 0,
    startTime: performance.now(),
    duration: ANIM_DURATION,
    currentAngle: 0,
  };
  requestAnimationFrame(animateTurn);
}

function processQueue() {
  if (moveQueue.length > 0) {
    const [m, ccw] = moveQueue.shift();
    doMove(m, ccw);
  }
}

function scramble() {
  const moves = 'UDLRFB';
  moveCount = 0;
  moveQueue = [];
  // Queue 20 random moves with fast animation
  for (let i = 0; i < 20; i++) {
    const m = moves[Math.floor(Math.random() * 6)];
    const ccw = Math.random() > 0.5;
    moveQueue.push([m, ccw]);
  }
  // Override animation duration for scramble
  const origDuration = ANIM_DURATION;
  const fastScramble = () => {
    if (moveQueue.length === 0) return;
    const [m, ccw] = moveQueue.shift();
    anim = {
      face: m, ccw, progress: 0,
      startTime: performance.now(),
      duration: 50,
      currentAngle: 0,
    };
    const tick = () => {
      const now = performance.now();
      const elapsed = now - anim.startTime;
      const t = Math.min(1, elapsed / anim.duration);
      const targetAngle = anim.ccw ? -Math.PI / 2 : Math.PI / 2;
      anim.currentAngle = targetAngle * easeOutCubic(t);
      draw();
      if (t < 1) {
        requestAnimationFrame(tick);
      } else {
        applyMove(anim.face, anim.ccw);
        moveCount++;
        anim = null;
        draw();
        updateStats();
        fastScramble();
      }
    };
    requestAnimationFrame(tick);
  };
  fastScramble();
}

function resetCube() {
  initFaces();
  moveCount = 0;
  moveQueue = [];
  anim = null;
  draw();
  updateStats();
}

// Mouse drag to rotate — x-axis MIRRORED for natural feel
canvas.addEventListener('mousedown', (e) => {
  dragging = true;
  dragStartX = e.clientX;
  dragStartY = e.clientY;
  dragStartRotX = rotX;
  dragStartRotY = rotY;
});

window.addEventListener('mousemove', (e) => {
  if (!dragging) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  rotY = dragStartRotY - dx * 0.008; // MIRRORED: negative dx
  rotX = dragStartRotX - dy * 0.008;
  rotX = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, rotX));
  draw();
});

window.addEventListener('mouseup', () => { dragging = false; });

// Gentle idle rotation
let idleAnim = null;
function startIdle() {
  if (dragging) return;
  idleAnim = requestAnimationFrame(idleTick);
}
function idleTick() {
  if (dragging || anim) { idleAnim = requestAnimationFrame(idleTick); return; }
  rotY += 0.003;
  draw();
  idleAnim = requestAnimationFrame(idleTick);
}

initFaces();
draw();
updateStats();
startIdle();
</script>
</body>
</html>
